// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "Async/Future.h"
#include "Containers/Array.h"
#include "Containers/UnrealString.h"
#include "Misc/DateTime.h"
#include "Misc/Optional.h"
#include "Misc/Variant.h"
#include "Serialization/JsonSerializable.h"
#include "Serialization/JsonSerializerMacros.h"
#include "Templates/Function.h"
#include "Templates/SharedPointer.h"
#include "Templates/Tuple.h"
#include "Templates/UnrealTemplate.h"
#include "Templates/ValueOrError.h"
#include "UObject/StrongObjectPtr.h"

#include "AIAssistantEnum.h"
#include "AIAssistantJsonVariantSerializer.h"
#include "AIAssistantWebJavaScriptDelegateBinder.h"
#include "AIAssistantWebJavaScriptExecutor.h"
#include "AIAssistantWebJavaScriptResultDelegate.h"

namespace UE::AIAssistant
{
	// Interface for a subset of the Epic Developer Assistant API.

	// Role of the message author / source.
	enum class EMessageRole
	{
		Agent,
		User,
	};

	#define UE_AI_ASSISTANT_MESSAGE_ROLE_ENUM(X) \
		X(EMessageRole::Agent, "agent"), \
		X(EMessageRole::User, "user")

	UE_ENUM_METADATA_DECLARE(EMessageRole, UE_AI_ASSISTANT_MESSAGE_ROLE_ENUM);

	// Type of content added to a message (text and tool calls now, images etc. in future)
	enum class EMessageContentType
	{
		Text,
	};

	#define UE_AI_ASSISTANT_MESSAGE_CONTENT_TYPE_ENUM(X) \
		X(EMessageContentType::Text, "text")

	UE_ENUM_METADATA_DECLARE(EMessageContentType, UE_AI_ASSISTANT_MESSAGE_CONTENT_TYPE_ENUM);

	// Text message content.
	struct FTextMessageContent : public FJsonSerializable
	{
		FString Text;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE("text", Text);
		END_JSON_SERIALIZER
	};

	// Content of a message.
	struct FMessageContent : public FJsonSerializable
	{
		// Type of the messageContent field.
		EMessageContentType ContentType;
		// Content of the message, this can be extended in future to support additional types of content.
		TVariant<FTextMessageContent> Content;
		// Whether the message is visible to the user.
		bool bVisibleToUser = true;

		BEGIN_JSON_SERIALIZER
			UE_JSON_SERIALIZE_ENUM_VARIANT_BEGIN("contentType", ContentType, "content", Content);
				UE_JSON_SERIALIZE_ENUM_VARIANT(EMessageContentType::Text, FTextMessageContent);
			UE_JSON_SERIALIZE_ENUM_VARIANT_END();
			JSON_SERIALIZE_WITHDEFAULT("visibleToUser", bVisibleToUser, true);
		END_JSON_SERIALIZER

	};

	// Message within a conversation.
	struct FMessage : public FJsonSerializable
	{
		// When the message was created (UTC). This is populated on the server side and ignored when
		// specified on the client side.
		TOptional<FDateTime> Date;

		// Role or source of the message.
		EMessageRole MessageRole;

		// Content of the message.
		TArray<FMessageContent> MessageContent;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE_OPTIONAL("date", Date);
			JSON_SERIALIZE_ENUM("messageRole", MessageRole);
			JSON_SERIALIZE_ARRAY_SERIALIZABLE("messageContent", MessageContent, FMessageContent);
		END_JSON_SERIALIZER
	};

	// ID of a conversation, generated by the assistant backend.
	struct FConversationId : public FJsonSerializable
	{
		// Unique ID of the conversation.
		FString Id;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE("id", Id);
		END_JSON_SERIALIZER
	};


	// Argument for AddMessageToConversation.
	struct FAddMessageToConversationOptions : public FJsonSerializable
	{
		// ID of the conversation to add the message to.
		// If this is not specified, the message is added to the current conversation.
		TOptional<FConversationId> ConversationId;
		// Message to add to the conversation.
		FMessage Message;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE_OPTIONAL_OBJECT_SERIALIZABLE("conversationId", ConversationId);
			JSON_SERIALIZE_OBJECT_SERIALIZABLE("message", Message);
		END_JSON_SERIALIZER
	};

	// High level descriptor of the environment is interacting with.
	struct FAgentEnvironmentDescriptor : public FJsonSerializable {
		// Name of the current environment.
		// NOTE: This is a string so that this can be extended without
		// modifying anything in the data path from the assistant client to
		// the backend.
		// Valid values are initially “Web”, “UE”, “UEFN”.
		FString EnvironmentName;
		// If applicable, the version of the environment. For example, given
		// a particular release version of the Unreal Engine this may allow
		// the assistant backend to reference a particular set of
		// documentation.
		FString EnvironmentVersion;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE("environmentName", EnvironmentName);
			JSON_SERIALIZE("environmentVersion", EnvironmentVersion);
		END_JSON_SERIALIZER
	};

	// Description of the agent's environment.
	// NOTE: This will be extended in future to support exposing environment
	// specific functions to the agent.
	struct FAgentEnvironment : public FJsonSerializable
	{
		// Very high level description of the environment.
		FAgentEnvironmentDescriptor Descriptor;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE_OBJECT_SERIALIZABLE("descriptor", Descriptor);
		END_JSON_SERIALIZER
	};

	// Permanent storage ID of an agent environment
	// (e.g database generated ID)
	struct FAgentEnvironmentId : public FJsonSerializable
	{
		FString Id;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE("id", Id);
		END_JSON_SERIALIZER
	};

	// Hash of an agent environment.
	struct FAgentEnvironmentHash : public FJsonSerializable
	{
		// Name of the hash algorithm. If this is not specified, use SHA256.
		FString Algorithm;
		// Hash of the AgentEnvironment.
		FString Hash;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE("algorithm", Algorithm);
			JSON_SERIALIZE("hash", Hash);
		END_JSON_SERIALIZER
	};

	// Handle to an agent environment.
	struct FAgentEnvironmentHandle : public FJsonSerializable
	{
		// ID of the agent environment.
		FAgentEnvironmentId Id;
		// Hash of the environment.
		FAgentEnvironmentHash Hash;

		BEGIN_JSON_SERIALIZER
			JSON_SERIALIZE_OBJECT_SERIALIZABLE("id", Id);
			JSON_SERIALIZE_OBJECT_SERIALIZABLE("hash", Hash);
		END_JSON_SERIALIZER
	};

	class FWebApiAccessor;

	// API to communicate with the web assistant.
	class FWebApi : private IWebJavaScriptDelegateBinder, public FNoncopyable
	{
		friend class FWebApiAccessor;

	public:
		FWebApi(IWebJavaScriptExecutor& JavaScriptExecutor,
				IWebJavaScriptDelegateBinder& JavaScriptDelegateBinder);

		// Prevent copy.
		//FWebApi(const FWebApi&) = delete;
		//FWebApi& operator=(const FWebApi&) = delete;
		

		virtual ~FWebApi();

		// Add a message to a conversation.
		void AddMessageToConversation(const FAddMessageToConversationOptions& Options);

		// Create a new conversation.
		TFuture<TValueOrError<void, FString>> CreateConversation();

		// Add an agent environment for the currently logged in user
		// returning the ID. If a matching environment already exists for the
		// user, this should return the existing environment (i.e upsert).
		TFuture<TValueOrError<FAgentEnvironmentHandle, FString>> AddAgentEnvironment(
			const FAgentEnvironment& AgentEnvironment);

		// Set agent environment for the conversational UI.
		void SetAgentEnvironment(const FAgentEnvironmentId& AgentEnvironmentId);

		void UpdateGlobalLocale(const FString& LocaleString);

	protected:
		// Format a function call of a member with result handling.
		FString FormatFunctionCall(
			const TCHAR* FunctionName, const TCHAR* Arguments = TEXT(""),
			const FString& HandlerId = FString());

		// Format JavaScript for result and error handler function calls.
		TPair<FString, FString> FormatResultAndErrorHandlers(const FString& HandlerId);

		// Execute a javascript function getting the result as a JSON encoded string.
		TFuture<UAIAssistantWebJavaScriptResultDelegate::FResult> ExecuteFunction(
			const TCHAR* FunctionName, const TCHAR* Arguments = TEXT(""));

		// Execute a javascript function handling the result with the specified handler.
		// NOTE: This is virtual so tests can capture the function, arguments and handler ID before
		// they're inserted into a script.
		virtual void ExecuteAsyncFunction(
			const TCHAR* FunctionName, const TCHAR* Arguments, const TCHAR* HandlerId);

		// Execute a javascript function converting an argument to JSON.
		template<typename JsonSerializableArgType>
		TFuture<UAIAssistantWebJavaScriptResultDelegate::FResult> ExecuteFunctionWithJsonArgument(
			const TCHAR* FunctionName, const JsonSerializableArgType& Argument)
		{
			return ExecuteFunction(FunctionName, *Argument.ToJson(false));
		}

		// Create a promise and handler for the execution of a JavaScript function that optionally
		// parses a JSON result value.
		template<typename JsonSerializableReturnType>
		TTuple<
			TSharedPtr<TPromise<TValueOrError<JsonSerializableReturnType, FString>>>, 
			TFunction<void(const TFuture<UAIAssistantWebJavaScriptResultDelegate::FResult>&)>>
			CreatePromiseAndHandlerForFunction()
		{
			auto Result =
				MakeShared<TPromise<TValueOrError<JsonSerializableReturnType, FString>>>();
			auto ResultHandler =
				[Result](
					const TFuture<UAIAssistantWebJavaScriptResultDelegate::FResult>&
					ExecutionResultFuture) mutable -> void
				{
					auto ExecutionResult = ExecutionResultFuture.Get();
					const FString& Json = ExecutionResult.Json;
					if (ExecutionResult.bJsonIsError)
					{
						Result->SetValue(MakeError(Json));
					}
					else
					{
						Result->SetValue(ParseJsonIfNotVoid<JsonSerializableReturnType>(Json));
					}
				};
			return MakeTuple(Result, MoveTemp(ResultHandler));
		}

		// Execute a function with no arguments optionally marshalling a return value from JSON or
		// setting an error.
		template<typename JsonSerializableReturnType>
		TFuture<TValueOrError<JsonSerializableReturnType, FString>>
			ExecutionFunctionParseJson(const TCHAR* FunctionName)
		{
			auto ResultAndHandler = CreatePromiseAndHandlerForFunction<JsonSerializableReturnType>();
			ExecuteFunction(FunctionName).Then(MoveTemp(ResultAndHandler.Value));
			return ResultAndHandler.Key->GetFuture();
		}

		// Execute a function marshalling an argument to JSON and the return value from JSON or
		// setting an error.
		template<typename JsonSerializableReturnType, typename JsonSerializableArgType>
		TFuture<TValueOrError<JsonSerializableReturnType, FString>>
			ExecutionFunctionParseJson(
				const TCHAR* FunctionName,
				const JsonSerializableArgType& Argument)
		{
			auto ResultAndHandler = CreatePromiseAndHandlerForFunction<JsonSerializableReturnType>();
			ExecuteFunctionWithJsonArgument(FunctionName, Argument).Then(
				MoveTemp(ResultAndHandler.Value));
			return ResultAndHandler.Key->GetFuture();
		}

		// Parse a JSON string if JsonSerializableReturnType is not void otherwise return an empty value.
		template<typename JsonSerializableReturnType>
		static TValueOrError<JsonSerializableReturnType, FString> ParseJsonIfNotVoid(const FString& Json)
		{
			JsonSerializableReturnType Parsed;
			if (!Parsed.FromJson(Json))
			{
				return MakeError(FString(TEXT("Failed to parse: ")) + Json);
			}
			return MakeValue(MoveTemp(Parsed));
		}

		// Overload that ignores the supplied JSON string and returns an empty value.
		template<>
		inline TValueOrError<void, FString> ParseJsonIfNotVoid(const FString& UnusedJson)
		{
			return MakeValue();
		}

	private:
		// Call the underlying binder.
		void BindUObject(const FString& Name, UObject* Object, bool bIsPermanent = true) override;

		// Unbind from the underlying binder and remove the reference to
		// WebJavaScriptResultDelegate as it is likely being destroyed.
		void UnbindUObject(const FString& Name, UObject* Object, bool bIsPermanent = true) override;

	protected:
		IWebJavaScriptExecutor& WebJavaScriptExecutor;
		IWebJavaScriptDelegateBinder& WebJavaScriptDelegateBinder;
		TStrongObjectPtr<UAIAssistantWebJavaScriptResultDelegate> WebJavaScriptResultDelegate;

	private:
		// Name of the global object that implements the web API.
		static const FString WebApiObjectName;

		// FString::Format() template that requires:
		// * WebApiObjectName: Should be FWebApi::WebApiObjectName.
		// * FunctionName: Name of the function to call on WebApiObjectName.
		// * Arguments: String that contains the arguments to pass to the function.
		// * NotifyHandlerOfResult: JavaScript snippet that is called with "result" to handle
		//   the result of the function.
		// * NotifyHandlerOfError: JavaScript snippet that is called with "error" to handle
		//   a function error.
		static const FString FunctionCallFormatTemplate;
	};
}
